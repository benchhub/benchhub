package generator

import (
	"io"
	"path/filepath"

	"github.com/dyweb/gommon/errors"

	"github.com/dyweb/gommon/generator"

	"github.com/dyweb/gommon/util/stringutil"

	"github.com/benchhub/benchhub/lib/plural"
	"github.com/benchhub/benchhub/lib/tqbuilder/sql/ddl"
	"github.com/dyweb/gommon/util/fsutil"
)

// ----------------------------------------------------------------------------
// GenDDLMain generates a main.go as entry point for DDL related code gen

const ddlSuffix = "ddl"

const ddlMainTemplate = `
// Code generated by tqbuilder DO NOT EDIT.

package main

import (
	dlog "github.com/dyweb/gommon/log"
	"github.com/dyweb/gommon/errors"
	"github.com/benchhub/benchhub/lib/tqbuilder/generator"

{{ range .DDLImports }}
	{{ .Name }} "{{ .Path }}"
{{- end }}
)

var (
	logReg = dlog.NewRegistry()
	log = logReg.NewLogger()
)

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	ddls := []generator.DDLTables{
{{ range .DDLImports }}
		{
			ImportPath: "{{ .Path }}",
			Package: "{{ .Package }}",
			Tables: {{ .Name }}.Tables(),
			OutputPath: "{{ .OutputPath }}",
		},
{{- end }}
	}
	merr := errors.NewMultiErr()
	for _, ddl := range ddls {
		merr.Append(generator.GenDDL(ddl))
	}
	return merr.ErrorOrNil()
}
`

// TODO(style): add this go style
type ddlMainTemplateData struct {
	DDLImports []ddlImport
}

// ddlImport is only used in template
type ddlImport struct {
	Name       string // import alias in generated go code
	Path       string // import path
	Package    string // extracted package name, e.g. user, act etc.
	OutputPath string // relative path to output generated files, e.g. core/services/user/schema/generated
}

// DDLTables contains tables definitions from a go a package.
// It is used by GenDDL to generate actual struct, table schema, SQL etc.
type DDLTables struct {
	ImportPath string         // import path
	Package    string         // copied from DDLImport name for generating new package name. e.g. user -> usermodel
	Tables     []ddl.TableDef // from user defined schema, we expect the package has a `Tables() []ddl.TableDef` method
	OutputPath string         // copied from DDLImport, e.g. core/services/user/schema/generated
}

// GenDDLMain generates a main.go file that will do the real code generation when executed.
// User should write table definition in go code under specific path. Those path are extracted using Walk.
// It simply renders a go file from template.
func GenDDLMain(dst io.Writer, ddls []ExtractedPath) error {
	var ddlImports []ddlImport
	for _, ep := range ddls {
		ddlImports = append(ddlImports, ddlImport{
			// Generate unique import name based on path, otherwise they are all called ddl
			// FIXME: it is no longer unique if there are packages with same name ...\
			Name:       ep.Package + ddlSuffix, // userddl
			Path:       ep.ImportPath,
			Package:    ep.Package,
			OutputPath: ep.OutputPath,
		})
	}
	tmpl := generator.GoCodeTemplate{
		Name:    "ddlmain",
		Content: ddlMainTemplate,
		Data:    ddlMainTemplateData{DDLImports: ddlImports},
	}
	return generator.RenderGoCodeTo(dst, tmpl)
}

// ----------------------------------------------------------------------------
// GenDDL

// GenDDL generates table(s) for a single package (service).
// It calls multiple generators and returns if any of them has error.
// - genDDLModel
// - genDDLSchema
func GenDDL(d DDLTables) error {
	gens := []struct {
		suffix    string
		generator func(dst io.Writer, d DDLTables) error
	}{
		{modelSuffix, genDDLModel},
		{schemaSuffix, gentDDLSchema},
		// TODO: markdown, sql
	}
	merr := errors.NewMulti()
	for _, gen := range gens {
		err := func() error {
			p := filepath.Join(d.OutputPath, d.Package+gen.suffix)
			log.Infof("GenDDL %s %s %d tables to %s", gen.suffix, d.ImportPath, len(d.Tables), p)
			// TODO: one file per table instead of everything in pkg.go
			f, err := fsutil.CreateFileAndPath(p, "pkg.go")
			if err != nil {
				return err
			}
			defer f.Close()
			return gen.generator(f, d)
		}()
		if merr.Append(err) {
			log.Warnf("%s %s", gen.suffix, err)
		}
	}
	return merr.ErrorOrNil()
}

// ----------------------------------------------------------------------------
// genDDLModel generates go struct from table schema

const modelSuffix = "model"

const ddlModelTemplate = `
// Code generated by tqbuilder from {{.DDLPath}} DO NOT EDIT.

package {{ .Package }}

{{ range .Structs }}
// {{ .Name }} is generated from table {{ .Table }}
type {{ .Name }} struct {
{{ range .Fields }}
	{{ .Name }} {{ .Type }} // {{ .Column }}
{{- end }}
}
{{ end }}
`

type ddlModelData struct {
	DDLPath string // path of ddl definition
	Package string // package name
	Structs []structDef
}

func table2GoModel(tbl ddl.TableDef) structDef {
	var fields []fieldDef
	for _, col := range tbl.Columns {
		// TODO: it is possible to add struct tags for runtime reflection etc.
		fields = append(fields, fieldDef{
			Column: col.Name,
			Name:   stringutil.SnakeToCamel(col.Name),
			Type:   col.Type.GoType(),
		})
	}
	structName := plural.ToSingular(tbl.Name)
	structName = stringutil.SnakeToCamel(structName)
	return structDef{
		Table:  tbl.Name,
		Name:   structName,
		Fields: fields,
	}
}

// genDDLModel generates go struct from table schema
func genDDLModel(dst io.Writer, d DDLTables) error {
	var structs []structDef
	for _, tbl := range d.Tables {
		structs = append(structs, table2GoModel(tbl))
	}
	tmpl := generator.GoCodeTemplate{
		Name:    "ddlmodel",
		Content: ddlModelTemplate,
		Data: ddlModelData{
			DDLPath: d.ImportPath,
			Package: d.Package + modelSuffix,
			Structs: structs,
		},
	}
	return generator.RenderGoCodeTo(dst, tmpl)
}

// ----------------------------------------------------------------------------
// genSchema generates table definition for dml builder

const schemaSuffix = "schema"

const ddlSchemaTemplate = `
// Code generated by tqbuilder from {{.DDLPath}} DO NOT EDIT.

package {{ .Package }}

import (
	"github.com/benchhub/benchhub/lib/tqbuilder/sql/ddl"
)

{{ range .Tables }}
// ----------------------------------------------------------------------------
// {{ .Name }}

var {{ .Name }} = new{{ .Name }}()

// {{ .Struct.Name }} is generated from table {{ .Table.Name }}
type {{ .Struct.Name }} struct {
{{ range .Struct.Fields }}
	{{ .Name }} {{ .Type }} // {{ .Column }}
{{- end }}
}

func new{{ .Name }}() {{ .Struct.Name }} {
	// TODO: fill in column def etc.
}
{{ end }}
`

type ddlSchemaData struct {
	DDLPath string
	Package string
	Tables  []ddlSchemaTable
}

// TODO: the naming is a bit confusing ...
type ddlSchemaTable struct {
	Name   string
	Struct structDef
	Table  ddl.TableDef
}

func table2SchemaTable(tbl ddl.TableDef) ddlSchemaTable {
	var fields []fieldDef
	for _, col := range tbl.Columns {
		fields = append(fields, fieldDef{
			Column: col.Name,
			Name:   stringutil.SnakeToCamel(col.Name),
			Type:   "ddl.ColumnDef",
		})
	}
	name := plural.ToSingular(tbl.Name)
	name = stringutil.SnakeToCamel(name)
	structName := name + "Table"
	st := structDef{
		Table:  tbl.Name,
		Name:   structName,
		Fields: fields,
	}
	return ddlSchemaTable{
		Name:   name,
		Struct: st,
		Table:  tbl,
	}
}

func gentDDLSchema(dst io.Writer, d DDLTables) error {
	var tbls []ddlSchemaTable
	for _, tbl := range d.Tables {
		tbls = append(tbls, table2SchemaTable(tbl))
	}
	tmpl := generator.GoCodeTemplate{
		Name:    "ddlschema",
		Content: ddlSchemaTemplate,
		Data: ddlSchemaData{
			DDLPath: d.ImportPath,
			Package: d.Package + schemaSuffix,
			Tables:  tbls,
		},
	}
	return generator.RenderGoCodeTo(dst, tmpl)
}
