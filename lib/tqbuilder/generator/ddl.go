package generator

import (
	"io"
	"strings"

	"github.com/benchhub/benchhub/lib/plural"
	"github.com/benchhub/benchhub/lib/tqbuilder/sql/ddl"
	"github.com/dyweb/gommon/errors"
	"github.com/dyweb/gommon/util/genutil"
)

const ddlMainTemplate = `
// Code generated by tqbuilder DO NOT EDIT.

package main

import (
	dlog "github.com/dyweb/gommon/log"
	"github.com/dyweb/gommon/errors"
	"github.com/benchhub/benchhub/lib/tqbuilder/generator"

{{ range .DDLImports }}
	{{ .Name }} "{{ .Path }}"
{{- end }}
)

var (
	logReg = dlog.NewRegistry()
	log = logReg.NewLogger()
)

func main() {
	ddls := []generator.DDLTables{
{{ range .DDLImports }}
		{
			Path: "{{ .Path }}",
			Package: "{{ .Package }}",
			Tables: {{ .Name }}.Tables(),
		},
{{- end }}
	}
	merr := errors.NewMultiErr()
	for _, ddl := range ddls {
		merr.Append(generator.GenDDL(ddl))
	}
	if merr.HasError() {
		log.Fatal(merr.ErrorOrNil())
	}
}
`

type DDLImport struct {
	Name    string // import alias in generated go code
	Path    string // import path
	Package string // extracted package name, e.g. user, act etc.
}

type DDLTables struct {
	Path    string
	Package string // extracted package name for generating new package name. e.g. user -> usermodel
	Tables  []ddl.TableDef
}

// GenDDLMain generates a main.go file that can generate go binding and SQL
// based on DDL ast written in go.
func GenDDLMain(dst io.Writer, importPrefix string, ddls []string) error {
	// Generate unique import name based on path
	// TODO: it is no longer unique if there are packages with same name ...\
	var ddlImports []DDLImport
	for _, ddlPath := range ddls {
		// user/schema/ddl -> userddl
		segs := strings.Split(ddlPath, "/")
		if len(segs) < 3 {
			return errors.Errorf("expect at least 3 segments in ddl path, got %d from %s", len(segs), ddlPath)
		}
		pkg := segs[len(segs)-3] // user
		name := pkg + "ddl"      // userddl
		ddlImports = append(ddlImports, DDLImport{
			Name: name,
			// core/services/user/schema/ddl -> github.com/benchhub/benchhub/core/services/user/schema/ddl
			Path:    importPrefix + "/" + ddlPath,
			Package: pkg,
		})
	}

	data := map[string]interface{}{
		"DDLImports": ddlImports,
	}
	return renderTo("ddlmain", dst, ddlMainTemplate, data)
}

// GenDDL generates table(s) for a single package (service).
func GenDDL(d DDLTables) error {
	log.Infof("GenDDL TODO: %s %d", d.Path, len(d.Tables))

	// TODO: need the path to save generated file
	// core/services/user/schema/generated
	// this need to be generated in previous phase
	return nil
}

const ddlModelTemplate = `
// Code generated by tqbuilder from {{.DDLPath}} DO NOT EDIT.

package {{ .Package }}

{{ range .Structs }}
type {{ .Name }} struct {
{{ range .Fields }}
	{{ .Name }} {{ .Type }}
{{ end }}
}
{{ end }}
`

type ddlModelData struct {
	DDLPath string // path of ddl definition
	Package string // package name
	Structs []structDef
}

func genDDLModel(dst io.Writer, d DDLTables) error {
	var structs []structDef
	for _, tbl := range d.Tables {
		var fields []fieldDef
		for _, f := range tbl.Columns {
			fields = append(fields, fieldDef{
				Name: genutil.UcFirst(f.Name),
				Type: f.Type.GoType(),
			})
		}
		structName := plural.ToSingular(tbl.Name)
		structName = genutil.UcFirst(structName)
		structs = append(structs, structDef{
			Name:   structName,
			Fields: fields,
		})
	}
	data := ddlModelData{
		DDLPath: d.Path,
		Package: d.Package + "model",
		Structs: structs,
	}
	return renderTo("ddlmodel", dst, ddlModelTemplate, data)
}
