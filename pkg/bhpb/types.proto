// protoc --proto_path=/home/at15/workspace/src/:. --gogo_out=. types.proto
syntax = "proto3";
package bh;

option go_package = "bhpb";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.sizer_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;

// ---------------------------
//           <error>
// ---------------------------

enum ErrorCode {
    UNKNOWN_ERROR = 0;
    ALREADY_EXISTS = 1;
    NOT_FOUND = 2;
    INVALID_CONFIG = 3;
    PERMISSION_DENIED = 4;
    STORE_ERROR = 5;
}

enum ErrorSource {
    UNKNOWN_SOURCE = 0;
    SOURCE_CENTRAL = 1;
    SOURCE_AGENT = 2;
    SOURCE_META_STORE = 3;
    SOURCE_TS_STORE = 4;
}

message Error {
    ErrorCode code = 1;
    ErrorSource source = 2;
    string message = 3;
    string nodeId = 4;
}

// ---------------------------
//           </error>
// ---------------------------

// ---------------------------
//     <label alike>
// ---------------------------

message Label {
    string k = 1;
    string v = 2;
}

message Env {
    string k = 1;
    string v = 2;
}
// ---------------------------
//      </label alike>
// ---------------------------

// ---------------------------
//      <node=info+status>
// ---------------------------

message Node {
    NodeInfo info = 1 [(gogoproto.nullable) = false];
    NodeStatus status = 2 [(gogoproto.nullable) = false];
}

// ---------------------------
//      </node=info+status>
// ---------------------------

// ---------------------------
//       <node config>
// ---------------------------
message NodeConfig {
    Role role = 1;
    NodeProvider provider = 2 [(gogoproto.nullable) = false];
    repeated Label labels = 3 [(gogoproto.nullable) = false];
}

enum Role {
    UNKNOWN_ROLE = 0;
    ANY = 1; // 随便 都行
    CENTRAL = 2;
    LOADER = 3;
    DATABASE = 4;
}

// TODO: use provider enum
message NodeProvider {
    string name = 1;
    string region = 2;
    string instance = 3;
}

enum Provider {
    UNKNOWN_PROVIDER = 0;
    LOCAL_PROVIDER = 1; // local dev environment
    VAGRANT_PROVIDER = 2; // vagrant, mostly local
    ALI_PROVIDER = 3;
    AWS_PROVIDER = 4;
    AZURE_PROVIDER = 5;
    GCP_PROVIDER = 6;
    PACKET_PROVIDER = 7;
}

// ---------------------------
//       </node config>
// ---------------------------

// --------------------------------------------
// <node info=id+addr+config+capacity+property>
// --------------------------------------------

// NodeInfo is provided to central when agent register
message NodeInfo {
    // self generated uid, used through a node agent's lifetime, change after process restart
    // https://github.com/benchhub/benchhub/issues/17
    string id = 1;
    // node addr, bindAddr is from config, remoteAddr is from other nodes
    Addr addr = 2 [(gogoproto.nullable) = false];
    // config from configuration file, could be generated by provision tools
    NodeConfig config = 3 [(gogoproto.nullable) = false];
    // capacity snapshot taken when the node agent starts
    NodeCapacity capacity = 4 [(gogoproto.nullable) = false];
    // properties like host name, boot time
    NodeProperty property = 5 [(gogoproto.nullable) = false];
}

message Addr {
    // set when node start or obtain from remoteAddr
    // TODO: this is a workaround because I don't know how a client can know its ip without calling external service
    // TODO: https://github.com/benchhub/benchhub/issues/18 track this
    // hashicorp has https://github.com/hashicorp/go-sockaddr for consul
    string ip = 1;
    // addr grpc server listens on i.e. :6081, from node config file
    string bindAddr = 2;
    // remoteAddr that other node sees when this node communicate, the ip is accurate, but the port is random, not the listen port
    string remoteAddr = 3;
}

message NodeCapacity {
    // number of cpu cores
    int32 cores = 1;
    // free memory in MB
    int32 memoryFree = 2;
    // total memory in MB
    int32 memoryTotal = 3;
    // free disk space in MB
    int32 diskFree = 4;
    // total disk space in MB
    int32 diskTotal = 5;
}

message NodeProperty {
    // agent process start, unix ts in second
    int64 startTime = 1;
    // machine boot, unix ts in second
    int64 bootTime = 2;
    // hostname
    string host = 3;
}

// --------------------------------------------
// </node info=id+addr+config+capacity+property>
// --------------------------------------------

// ---------------------------
//       <node status>
// ---------------------------

message NodeStatus {
    NodeState state = 1;
    repeated NodeJobStatus jobs = 2 [(gogoproto.nullable) = false];
}

message NodeAssignedProperties {
    // uinque name in current job, used to refer assigned node in rest of the config
    string name = 1;
    // role in current job, could be different from role in configuration file
    // i.e. a Any node can become a Database or Loader node
    // values: database, loader
    Role role = 2;
}

message NodeJobStatus {
    // properties assigned to node in NodeAssignmentSpec
    NodeAssignedProperties properties = 1 [(gogoproto.nullable) = false];

    // TODO: status of one job on a single node, it is different from global job status because it does not contains node
    NodeJobState state = 3;
}

enum NodeState {
    UNKNOWN_NODE_STATE = 0;
    NODE_FINDING_CENTRAL = 1;
    NODE_IDLE = 2;
    NODE_RUNNING_JOB = 3;
}

enum NodeJobState {
    UNKNOWN_NODE_JOB_STATE = 0;
    NODE_JOB_RUNNING = 1;
    NODE_JOB_FINISHED = 2;
    NODE_JOB_ERROR = 3;
    NODE_JOB_WAITING_INSTRUCTION = 4;
    NODE_JOB_REPORTING = 5;
    NODE_JOB_CLEANUP = 6;
}

// ---------------------------
//       </node status>
// ---------------------------

// ---------------------------
//          <identity>
// ---------------------------

message Owner {
    string id = 1;
    string name = 2;
    OwnerType type = 3;
}

enum OwnerType {
    UNKNOWN_OWNER = 0;
    USER = 1;
    ORG = 2;
}

// ---------------------------
//          </identity>
// ---------------------------

// ---------------------------
//        <job spec>
// ---------------------------

message JobSpec {
    string id = 1;
    string name = 2;
    Owner owner = 3 [(gogoproto.nullable) = false];
    WorkloadSpec workload = 4 [(gogoproto.nullable) = false];
    repeated NodeAssignmentSpec nodeAssignments = 5 [(gogoproto.nullable) = false, (gogoproto.moretags) = "yaml:\"nodeAssignments\""];
    repeated StagePipelineSpec pipelines = 6 [(gogoproto.nullable) = false];
    repeated StageSpec stages = 7 [(gogoproto.nullable) = false];
}

// TODO: this is not used
message WorkloadSpec {
    string framework = 1;
    string frameworkVersion = 2 [(gogoproto.moretags) = "yaml:\"frameworkVersion\""];
    string database = 3;
    string databaseVersion = 4 [(gogoproto.moretags) = "yaml:\"databaseVersion\""];
}

message NodeAssignmentSpec {
    // select by name, role, label, resource
    // TODO: label and resource are not used in current implementation
    repeated NodeSelectorSpec selectors = 1 [(gogoproto.nullable) = false];

    // properties assigned to selected node, visiable to this job only
    NodeAssignedProperties properties = 2 [(gogoproto.nullable) = false];
}

message NodeSelectorSpec {
    // all is shortcut for select all nodes in order to install global packages, i.e. tldr
    bool all = 1;
    // none is shortcut for stages like stopper, where central tell all the nodes to stop long running tasks
    bool none = 2;
    string name = 3;
    Role role = 4;
    repeated Label labels = 5 [(gogoproto.nullable) = false];
}

message StagePipelineSpec {
    string name = 1; // unqiue in piplines
    repeated string stages = 2; // stages that can run in parallel
}

message StageSpec {
    // unqiue in job, used by rest of the config
    string name = 1;
    // if true, there MUST be one task that is background
    bool background = 2;
    // selct by name, role, the relation between multiple selector is OR, NOT AND
    repeated NodeSelectorSpec selectors = 3 [(gogoproto.nullable) = false];
    repeated TaskPipelineSpec pipelines = 4 [(gogoproto.nullable) = false];
    repeated TaskSpec tasks = 5 [(gogoproto.nullable) = false];
}

message TaskPipelineSpec {
    string name = 1; // unique in pipelines
    repeated string tasks = 2; // tasks that can run in parallel
}

message TaskSpec {
    // unique in stage, MUST be specified if pipeline is used or is a background process
    string name = 1;
    // the stage contains this background task MUST also be background
    bool background = 2;
    TaskDriver driver = 3;
    repeated Env env = 4;

    // NOTE: we intentionly don't use [(gogoproto.nullable) = false], so we can check nil to see if config match driver
    StopperSpec stopper = 5;
    ShellSpec shell = 6;
    ExecSpec exec = 7;
    DockerSpec docker = 8;

    // readiness check for long running task
    ReadySpec ready = 9 [(gogoproto.nullable) = false];
    // TODO: liveness check ...
}

enum TaskDriver {
    UNKNOWN_TASKDRIVER = 0;
    STOPPER = 1;
    SHELL = 2;
    EXEC = 3;
    DOCKER = 4;
}

message StopperSpec {
    string stage = 1;
    string task = 2;
    bool all = 3; // stop all long running tasks in a stage
}

message ShellSpec {
    string command = 1;
}

message ExecSpec {
    string command = 1;
    repeated string args = 2;
}

enum DockerAction {
    UNKNOWN = 0;
    PULL = 1;
    RUN = 2;
}

message Port {
    int32 guest = 1;
    int32 host = 2;
}

message DockerSpec {
    string image = 1;
    DockerAction action = 2;
    repeated Port ports = 3 [(gogoproto.nullable) = false];
    // TODO: volume, different types of volume etc.
}

message ReadySpec {
    // at least one task, MUST NOT have long running task
    repeated TaskSpec tasks = 1 [(gogoproto.nullable) = false];
}

// ---------------------------
//        </job spec>
// ---------------------------

// ---------------------------
//        <job store>
// ---------------------------

// TODO: the whole job store part will be changed ...
message Job {
    string id = 1;
    string rawSpec = 2; // original job spec file content
    JobSpec spec = 3;

    int64 createTime = 4;
    int64 startTime = 5;
    int64 stopTime = 6;

    JobStatus status = 7;
    int64 currentPipeline = 8; // array index in pipelines
    repeated int64 foregroundStages = 9; // stages running in foreground
    repeated int64 backgroundStages = 10; // stages running in background
    repeated int64 finishedStages = 11; // finished stages, foreground or stopped background

    repeated StagePipeline pipelines = 12 [(gogoproto.nullable) = false];
    repeated Stage stages = 13 [(gogoproto.nullable) = false];

}

// TODO: the state of waiting for central to ack ?

enum JobStatus {
    UNKNOWN_JOB_STATUS = 0;
    JOB_QUEUED = 1;
    JOB_RUNNING = 2;
    JOB_FINISHED = 3;
    JOB_ABORTED = 4;
}

message StagePipeline {
    StagePipelineStatus status = 1;
    repeated int64 stages = 2; // index in stages
}

enum StagePipelineStatus {
    UNKNOWN_STAGE_PIPELINE_STATUS = 0;
    STAGE_PIPELINE_QUEUED = 1;
    STAGE_PIPELINE_RUNNING = 2;
    STAGE_PIPELINE_FINISHED = 3;
    STAGE_PIPELINE_BACKGROUND = 4;
}

message Stage {
    int64 index = 1; // array index in stages
    int64 pipeline = 2; // array index in piplines
    StageSpec spec = 3 [(gogoproto.nullable) = false]; // TODO: rendered stage spec
    repeated NodeStage nodes = 4 [(gogoproto.nullable) = false];
}

message NodeStage {
    string id = 1; // node id when agent register
    string name = 2; // name assigned in spec
    Role role = 3; // role specified when got assigned
    NodeInfo info = 4 [(gogoproto.nullable) = false]; // node info when agent register
    repeated TaskPipeline pipelines = 5 [(gogoproto.nullable) = false];
    repeated Task tasks = 6 [(gogoproto.nullable) = false];
}

message TaskPipeline {
    TaskPipelineStatus status = 1;
    repeated int64 tasks = 2;
}

enum TaskPipelineStatus {
    UNKNOWN_TASK_PIPELINE_STATUS = 0;
    TASK_PIPELINE_QUEUED = 1;
    TASK_PIPELINE_RUNNING = 2;
    TASK_PIPELINE_FINISHED = 3;
    TASK_PIPELINE_BACKGROUND = 4;
}

message Task {
    TaskStatus status = 1;

    int64 startTime = 2;
    int64 readyTime = 3;
    int64 stopTime = 4;
}

enum TaskStatus {
    UNKNOWN_TASK_STATUS = 0;
    TASK_QUEUED = 1;
    TASK_RUNNING = 2;
    TASK_BACKGROUND = 3;
    TASK_FINISHED = 4;
    TASK_ABORTED = 5;
}
// ---------------------------
//        </job store>
// ---------------------------

// ---------------------------
//       <job scheduler>
// ---------------------------
message AssignedNode {
    NodeInfo node = 1 [(gogoproto.nullable) = false];
    NodeAssignmentSpec spec = 2 [(gogoproto.nullable) = false];
}
// ---------------------------
//       </job scheduler>
// ---------------------------

// ---------------------------
//       <job plan>
// ---------------------------
message JobPlan {
    repeated StagePipelinePlan pipelines = 1 [(gogoproto.nullable) = false];
}

message StagePipelinePlan {
    string name = 1;
    repeated StagePlan stages = 2 [(gogoproto.nullable) = false];
}

// TODO: maybe stage plan should contains the original spec
message StagePlan {
    string name = 1;
    repeated AssignedNode nodes = 2 [(gogoproto.nullable) = false];
    repeated TaskPipelinePlan pipelines = 3 [(gogoproto.nullable) = false];
}

message TaskPipelinePlan {
    string name = 1;
    repeated TaskPlan tasks = 2 [(gogoproto.nullable) = false];
}

message TaskPlan {
    TaskSpec spec = 1 [(gogoproto.nullable) = false];
    // TODO: something else? render or expand etc.?
}

// ---------------------------
//       </job plan>
// ---------------------------

// ---------------------------
//       <common rpc>
// ---------------------------
message Ping {
    string message = 1;
}

message Pong {
    string message = 1;
}

message EmptyReq {
}

message NodeInfoReq {
}

message NodeInfoRes {
    NodeInfo node = 1 [(gogoproto.nullable) = false];
}
// ---------------------------
//       </common rpc>
// ---------------------------

// ---------------------------
//       <node rpc>
// ---------------------------
message RegisterAgentReq {
    NodeInfo node = 1 [(gogoproto.nullable) = false];
}

message RegisterAgentRes {
    Error error = 1;
    string id = 2; // uinque id for this agent assigned by central
    NodeInfo node = 3 [(gogoproto.nullable) = false]; // addr, ip, port would be added TODO: node should be able to find this out locally
    NodeInfo central = 4 [(gogoproto.nullable) = false]; // all the information about the central
}

message ListAgentReq {
}

message ListAgentRes {
    repeated Node agents = 1 [(gogoproto.nullable) = false];
}

message AgentHeartbeatReq {
    string id = 1;
    NodeStatus status = 2 [(gogoproto.nullable) = false];
}

message AgentHeartbeatRes {
    //    Job job = 1 [(gogoproto.nullable) = false];
    Error error = 1;
}

// ---------------------------
//       </node rpc>
// ---------------------------

// ---------------------------
//       <job rpc>
// ---------------------------
message SubmitJobReq {
    string user = 1;
    string spec = 2;
}

message SubmitJobRes {
    Error error = 1;
    string id = 2;
}

message JobStatusReq {
    string id = 1;
}

message JobStatusRes {

}
// ---------------------------
//       </job rpc>
// -------------------------